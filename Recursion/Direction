재귀의 접근법

재귀로 N~ 1까지 출력하는 함수
def recur(n):
    if n == 0:
        return
    print(n)
    recur(n - 1)

재귀로 1~N까지의 합을 구하는 함수
def recur(n):
    if n == 0:
        return 0
    return recur(n - 1) + n

이 코드가 왜 올바른 결과를 주는가? 를 잘생각해보자

어떤 문제를 재귀로 풀겠다는 것은 곧 귀납적인 방법으로 문제를 해결하겠다는 것이다.
귀납적인 방식은 지금까지의 내가 생각해왔던 절차지향적인 방식과는 큰 차이가 있다.

도미노의 예
<귀납적 방식> : 사실관계를 통해 정답을 추론하는 방식
fact1. 맨 앞의 도미노가 쓰러진다.
fact2. k번 도미노가 쓰러진다면 k + 1번 도미노도 쓰러진다.
따라서 모든 도미노가 쓰러진다. >> 위 두가지 fact를 통해 결과를 도출할 수 있어야 한다.

<절차적 방식> : 동작 흐름을 그대로 따라가는 방식.
1번 도미노가 쓰러짐 -> 2번 도미노가 쓰러짐 -> 3번 도미노가 쓰러짐 -> ... -> 마지막 도미노가 쓰러짐
따라서 모든 도미노가 쓰러진다.

재귀를 잘하려면 우리가 그동안 익숙했던 절차지향적인 방식에서 탈피를 해야한다.

이제 앞서 구현했던 함수를 귀납적 추론 방식으로 기술해보자
recur(1)은 1을 출력한다.
recur(2)는 2 1 을 출력한다.
결론 : recur(k)는 k k-1 ... 2 1을 출력한다는 참이다.

recur(k + 1)는 k+1 k k-1 ... 2 1을 출력한다. 를 보이면 된다.
>> recur(k + 1)을 호출했을 때 어떤 상황이 발생하는가?를 확인해보자.
recur(k + 1)을 호출하면 k+1을 출력하고 recur(k)를 호출한다.
결론 : recur(k + 1)는 k+1 k k-1 ... 2 1을 출력한다 는 참이다.

결론 2문장이 참이므로 recur(x)는 x x-1 x-2 ... 2 1을 출력한다.

1~N까지의 sum을 구하는 함수
가정1. recur(k)는 k + k-1 + ... 2 + 1을 리턴한다. 고 가정.
recur(k + 1)는 k+1 + k + k-1 + ... 2 + 1임을 보이자.
>> recur(k + 1)을 호출하였을 때 어떤 상황이 벌어지지?
k + 1을 더해주고 recur(k)를 호출한다.
recur(k)는 1~k까지의 합이라고 가정했다.
결론: 따라서 recur(k + 1)는 k+1 + k + k-1 + ... + 2 + 1을 만족한다.

이제 recur(k)가 1~k까지의 합인 것을 보이면 모든 증명이 완료된다.
recur(0)는 0을 리턴한다.
recur(1)은 1을 더하고 recur(0)을 호출한다.
recur(2)는 2를 더하고 recur(1)을 호출한다.
recur(k)는 k를 더하고 recur(k - 1)을 호출한다.
따라서 recur(k)는 1~k까지의 합이다.


재귀함수의 조건
1. 반드시 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 한다. >> base condition
2. 모든 입력은 base condition으로 수렴해야한다.
>> 이 두가지 조건을 지키지 못한다면 어떤 재귀함수던 무한 루프에 빠진다.
def recur(n):
    if n == 0: >> base condition
        return
    print(n)
    recur(n - 1)
모든 자연수 n은 base condition인 0으로 수렴하게 된다.


재귀 함수 팁
1. 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄 지 명확하게 정해야한다.
2. 모든 재귀함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
3. 재귀는 반복문으로 구현했을 때에 비해 코드가 간결해지지만 함수 호출이 꽤 비용이 큰 연산이므로 메모리와 시간 측면에서 손해를 본다.
>> 반복문으로 구현해기 매우 복잡한 문제일 경우에만 재귀를 활용한다!
4. 재귀는 한 함수가 자기자신을 여러번 호출하게 되면 비효율적일 수 있다. >> 피보나치 함수